{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/classifying-meta-tasks","result":{"data":{"brainNote":{"slug":"classifying-meta-tasks","title":"Classifying meta-tasks","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Classifying meta-tasks\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Vaguely, a meta-task is a task set where learning a given task from the set should help you learn other tasks from the set. That is, an agent should be able to \\\"transfer\\\" knowledge from learned tasks to a novel task.\"), mdx(\"p\", null, \"Here, I begin to classify meta-tasks. Any meta-task should be one or more of these types. If you can think of a meta-task that cannot be described by the following types, then this classification is incomplete (which I'm pretty sure it is as of now...)\"), mdx(\"h2\", null, \"Response remapping\"), mdx(\"p\", null, \"The first type of meta-task is a response remapping task. Here, tasks are equivalent up to permutation of state. That is, the optimal policy for both tasks are equivalent up to permutation. For example, consider a meta-task where an agent must either approach or evade animals. In one task, the agent must approach dogs and evade cats. And in another, the agent must approach cats and evade dogs. It's clear that the two tasks are equivalent up to permutation of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cats\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dogs\"), \". \"), mdx(\"p\", null, \"Here, the agent wants to map the external states \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cats\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dogs\"), \" onto internal latent states \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"scary animal\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cute animal\"), \". The only thing the agent has to change between tasks is the mapping of external state onto latent state, which should be easy enough with something like a soft dictionary. Note how similar this idea is to the core idea of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notebook/tolman-eichenbaum-machine\"\n  }), \"Tolman-Eichenbaum Machine\"), \", where place cells are the conjunctions of structure (i.e. location in graph, grid cells) and stimuli.\"), mdx(\"h2\", null, \"Overlapping sub-tasks\"), mdx(\"p\", null, \"Another type of meta-task is one with overlapping sub-tasks or sub-goals. In the \\\"flat\\\" case, the meta-task will consist of a set of stimulus-response pairs and individual tasks will consist of some subset of that set. For example, you may need to approach dogs and avoid cats in Wyoming. Additionally, you should avoid alligators in the Florida. Once you arrive in Florida, you shouldn't need to relearn that you should approach dogs and cats. You just need to learn the new response to the new stimulus (avoid gators).\"), mdx(\"p\", null, \"In the flat case, the important thing is that stimuli representations shouldn't interfere with each other. As long as they don't, you should be able to add new stimulus-response pairs.\"), mdx(\"p\", null, \"In the hierarchal case, the meta-task consists of a set of sub-tasks and an individual task consists of particular combinations of sub-tasks. For example, consider the meta-task of cooking and individual tasks as specific recipes. You shouldn't need to learn low-level cooking skills (e.g. chopping, pan-frying, etc.) from scratch. You just need to apply those skills in the right order, and to the right data (ingredients). This hierarchal case is of course the problem considered in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notebook/hierarchal-reinforcement-learning\"\n  }), \"Hierarchal reinforcement learning\"), \".\"), mdx(\"p\", null, \"The hierarchal case seems a lot trickier than the flat case:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How do you learn which parts of tasks are reusable and thus worth abstracting into sub-tasks? \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How do you make sub-tasks or sub-routines flexible to the data (e.g. you should be able to chop both onions and carrots about as easily)?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the sequential execution of sub-tasks, how do you decide when to switch from one task to another? In the \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/notebook/option-critic\"\n  }), \"Option-critic\"), \" architecture from \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/notebook/hierarchal-reinforcement-learning\"\n  }), \"Hierarchal reinforcement learning\"), \", options have termination states. Perhaps a more flexible version of this would have a switching policy with a context-switching cost, which may be a KL with the previous time-step or something like that.\")), mdx(\"br\", null), mdx(\"h2\", null, \"Dynamic reward distributions\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notebook/learning-to-reinforcement-learn-wang-2016\"\n  }), \"Learning to reinforcement learn (Wang 2016)\"), \". Reward functions change between tasks. In the stochastic case, \", mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"katex\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"katex-mathml\"\n  }), mdx(\"math\", _extends({\n    parentName: \"span\"\n  }, {\n    \"xmlns\": \"http://www.w3.org/1998/Math/MathML\"\n  }), mdx(\"semantics\", {\n    parentName: \"math\"\n  }, mdx(\"mrow\", {\n    parentName: \"semantics\"\n  }, mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"p\"), mdx(\"mo\", _extends({\n    parentName: \"mrow\"\n  }, {\n    \"stretchy\": \"false\"\n  }), \"(\"), mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"r\"), mdx(\"mi\", _extends({\n    parentName: \"mrow\"\n  }, {\n    \"mathvariant\": \"normal\"\n  }), \"\\u2223\"), mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"s\"), mdx(\"mo\", _extends({\n    parentName: \"mrow\"\n  }, {\n    \"stretchy\": \"false\"\n  }), \")\")), mdx(\"annotation\", _extends({\n    parentName: \"semantics\"\n  }, {\n    \"encoding\": \"application/x-tex\"\n  }), \"p(r|s)\")))), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"katex-html\",\n    \"aria-hidden\": \"true\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"base\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"1em\",\n      \"verticalAlign\": \"-0.25em\"\n    }\n  })), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mathdefault\"\n  }), \"p\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mopen\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mathdefault\",\n    \"style\": {\n      \"marginRight\": \"0.02778em\"\n    }\n  }), \"r\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord\"\n  }), \"\\u2223\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mathdefault\"\n  }), \"s\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mclose\"\n  }), \")\")))), \" may change from task-to-task. Response remapping can be seen as a specific case of this.\"), mdx(\"h2\", null, \"Dynamic state transitions\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"katex\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"katex-mathml\"\n  }), mdx(\"math\", _extends({\n    parentName: \"span\"\n  }, {\n    \"xmlns\": \"http://www.w3.org/1998/Math/MathML\"\n  }), mdx(\"semantics\", {\n    parentName: \"math\"\n  }, mdx(\"mrow\", {\n    parentName: \"semantics\"\n  }, mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"p\"), mdx(\"mo\", _extends({\n    parentName: \"mrow\"\n  }, {\n    \"stretchy\": \"false\"\n  }), \"(\"), mdx(\"msup\", {\n    parentName: \"mrow\"\n  }, mdx(\"mi\", {\n    parentName: \"msup\"\n  }, \"s\"), mdx(\"mo\", _extends({\n    parentName: \"msup\"\n  }, {\n    \"mathvariant\": \"normal\",\n    \"lspace\": \"0em\",\n    \"rspace\": \"0em\"\n  }), \"\\u2032\")), mdx(\"mi\", _extends({\n    parentName: \"mrow\"\n  }, {\n    \"mathvariant\": \"normal\"\n  }), \"\\u2223\"), mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"s\"), mdx(\"mo\", _extends({\n    parentName: \"mrow\"\n  }, {\n    \"stretchy\": \"false\"\n  }), \")\")), mdx(\"annotation\", _extends({\n    parentName: \"semantics\"\n  }, {\n    \"encoding\": \"application/x-tex\"\n  }), \"p(s'|s)\")))), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"katex-html\",\n    \"aria-hidden\": \"true\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"base\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"1.001892em\",\n      \"verticalAlign\": \"-0.25em\"\n    }\n  })), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mathdefault\"\n  }), \"p\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mopen\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mathdefault\"\n  }), \"s\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"msupsub\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"vlist-t\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"vlist-r\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"vlist\",\n    \"style\": {\n      \"height\": \"0.751892em\"\n    }\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"style\": {\n      \"top\": \"-3.063em\",\n      \"marginRight\": \"0.05em\"\n    }\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"pstrut\",\n    \"style\": {\n      \"height\": \"2.7em\"\n    }\n  })), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"sizing reset-size6 size3 mtight\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mtight\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mtight\"\n  }), \"\\u2032\"))))))))), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord\"\n  }), \"\\u2223\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mord mathdefault\"\n  }), \"s\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"mclose\"\n  }), \")\")))), \" changes from task-to-task.\"), mdx(\"br\", null), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"People:\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/notebook/nick\"\n  }), \"Nick\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/notebook/chris\"\n  }), \"Chris\"))), mdx(\"br\", null));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[{"title":"tolman-eichenbaum-machine","slug":"tolman-eichenbaum-machine","childMdx":{"excerpt":""}},{"title":"hierarchal-reinforcement-learning","slug":"hierarchal-reinforcement-learning","childMdx":{"excerpt":""}},{"title":"option-critic","slug":"option-critic","childMdx":{"excerpt":""}},{"title":"learning-to-reinforcement-learn-wang-2016","slug":"learning-to-reinforcement-learn-wang-2016","childMdx":{"excerpt":""}},{"title":"nick","slug":"nick","childMdx":{"excerpt":""}},{"title":"chris","slug":"chris","childMdx":{"excerpt":""}}]},"site":{"siteMetadata":{"title":"Rheza's working notes"}}},"pageContext":{"slug":"classifying-meta-tasks"}}}